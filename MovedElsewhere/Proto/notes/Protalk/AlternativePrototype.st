SystemOrganization addCategory: #AlternativePrototype!Object subclass: #Lobby	instanceVariableNames: 'delegate methods format instanceVariables organization'	classVariableNames: 'Root'	poolDictionaries: ''	category: 'AlternativePrototype'!!Lobby class methodsFor: 'as yet unclassified' stamp: 'ms 2/7/2009 13:24'!buildArray	"To Do"! !!Lobby class methodsFor: 'as yet unclassified' stamp: 'ms 2/7/2009 13:22'!buildRootEnvironment	self root addInstVar: #environment put: Dictionary new.! !!Lobby class methodsFor: 'as yet unclassified' stamp: 'ms 2/7/2009 13:29'!buildRootName	self root addInstVar: #name put: 'Lobby'.! !!Lobby class methodsFor: 'as yet unclassified' stamp: 'ms 2/7/2009 13:27'!buildString	"To Do"! !!Lobby class methodsFor: 'as yet unclassified' stamp: 'ms 2/7/2009 13:27'!buildSymbol	"To Do"! !!Lobby class methodsFor: 'as yet unclassified' stamp: 'ms 2/7/2009 13:33'!initialize	self buildRootEnvironment.	self root addToEnvrionment! !!Lobby class methodsFor: 'as yet unclassified' stamp: 'Gwenael.Casaccio 2/6/2009 16:03'!reboot	Root := nil.	self initialize.	^ self root! !!Lobby class methodsFor: 'as yet unclassified' stamp: 'Gwenael.Casaccio 2/6/2009 15:04'!root	"Root := nil"	^ Root ifNil:[Root := self new clone.		Root addInstVar: #name put: 'Lobby'.		Root]! !!Lobby class methodsFor: 'as yet unclassified' stamp: 'Gwenael.Casaccio 2/6/2009 15:36'!slotFor: anObject	| slot |	slot := self root clone: 2.	slot at: 2 put: anObject.	slot compile: 'run: selector with: arguments in: receiver	selector last == $:		ifTrue: [		receiver = (self at: 2) 			ifFalse: [receiver addInstVar: (selector copyWithout: $:) asSymbol put: arguments first] 			ifTrue: [self at: 1 put: arguments first]]		ifFalse: [ ^ self at: 1 ]'.	^ slot! !!Lobby methodsFor: 'accessing' stamp: 'Gwenael.Casaccio 2/6/2009 14:12'!addInstVar: aSymbol 	^ self primitiveAt: aSymbol! !!Lobby methodsFor: 'accessing' stamp: 'Gwenael.Casaccio 2/6/2009 14:39'!addInstVar: aSymbol put: anObject	^ self primitiveAt: aSymbol put: anObject! !!Lobby methodsFor: 'compiling' stamp: 'Gwenael.Casaccio 2/6/2009 13:35'!addSelector: selector withMethod: compiledMethod 		| oldMethodOrNil |	oldMethodOrNil := self lookupSelector: selector.	self methods at: selector put: compiledMethod.	compiledMethod methodClass: self.	compiledMethod selector: selector.	"Now flush Squeak's method cache, either by selector or by method"	oldMethodOrNil == nil ifFalse: [oldMethodOrNil flushCache].	selector flushCache.! !!Lobby methodsFor: 'instance creation' stamp: 'ms 2/7/2009 13:33'!addToEnvrionment	self environment at: self name asSymbol put: self! !!Lobby methodsFor: 'compiling' stamp: 'Gwenael.Casaccio 2/6/2009 13:35'!allInstVarNames	"Answer an Array of the names of the receiver's instance variables. The 	Array ordering is the order in which the variables are stored and 	accessed by the interpreter."	| vars |	delegate == nil		ifTrue: [vars := self instanceVariables copy]	"Guarantee a copy is answered."		ifFalse: [vars := delegate allInstVarNames , self instanceVariables].	^vars! !!Lobby methodsFor: 'compiling' stamp: 'Gwenael.Casaccio 2/6/2009 13:35'!binding	^ nil -> self! !!Lobby methodsFor: 'as yet unclassified' stamp: 'Gwenael.Casaccio 2/6/2009 16:40'!bindingOf: varName	"Answer the binding of some variable resolved in the scope of the receiver"	| aSymbol binding |	aSymbol := varName asSymbol.	"First look in classVar dictionary."	"binding := self classPool bindingOf: aSymbol.	binding ifNotNil:[^binding]."	"Next look in shared pools."	"self sharedPools do:[:pool | 		binding := pool bindingOf: aSymbol.		binding ifNotNil:[^binding].	]."	"Next look in declared environment."	binding := self environment bindingOf: aSymbol.	binding ifNotNil:[^binding].	"Finally look higher up the superclass chain and fail at the end."	delegate == nil		ifTrue: [^ nil]		ifFalse: [^ delegate bindingOf: aSymbol].! !!Lobby methodsFor: 'instance creation' stamp: 'Gwenael.Casaccio 2/6/2009 15:03'!clone	| clone |	clone := self primitiveNew initialize.	clone delegate: self.	clone format: self format.	clone methods: MethodDictionary new.	clone primitiveChangeClassTo: clone primitiveNew.	^ clone! !!Lobby methodsFor: 'instance creation' stamp: 'Gwenael.Casaccio 2/6/2009 15:27'!clone: size 	| temp clone |	temp := self primitiveNew initialize.	temp delegate: self.	temp format: LobbyVar format.	temp methods: MethodDictionary new.	clone := (temp primitiveNew: size) initializeVar.	clone delegate: self.	clone methods: MethodDictionary new.	clone primitiveChangeClassTo: (clone primitiveNew: size).	^ clone! !!Lobby methodsFor: 'compiling' stamp: 'Gwenael.Casaccio 2/6/2009 13:35'!compile: aString	| methodNode methodAndNode |	methodNode  := self compilerClass new				compile: aString				in: self				classified: ClassOrganizer default				notifying: nil				ifFail: [^nil].	methodAndNode := CompiledMethodWithNode generateMethodFromNode: methodNode trailer: self defaultMethodTrailer.	methodAndNode method putSource: aString fromParseNode: methodAndNode node inFile: 2			withPreamble: [:f | f cr; nextPut: $!!; nextChunkPut: 'Behavior method'; cr].	self addSelector: methodAndNode selector withMethod: methodAndNode method.	^methodAndNode selector! !!Lobby methodsFor: 'compiling' stamp: 'Gwenael.Casaccio 2/6/2009 13:35'!compiledMethodAt: selector 	^ self methods at: selector! !!Lobby methodsFor: 'compiling' stamp: 'Gwenael.Casaccio 2/6/2009 13:35'!compilerClass	"Answer a compiler class appropriate for source methods of this class."	^Compiler! !!Lobby methodsFor: 'compiling' stamp: 'Gwenael.Casaccio 2/6/2009 13:35'!defaultMethodTrailer	^ #(0 0 0 0)! !!Lobby methodsFor: 'compiling' stamp: 'Gwenael.Casaccio 2/6/2009 13:35'!defaultNameStemForInstances	"Answer a basis for external names for default instances of the receiver.	For classees, the class-name itself is a good one."	^ self name! !!Lobby methodsFor: 'accessing' stamp: 'Gwenael.Casaccio 2/6/2009 13:35'!delegate	^ delegate! !!Lobby methodsFor: 'accessing' stamp: 'Gwenael.Casaccio 2/6/2009 13:35'!delegate: anObject	delegate := anObject! !!Lobby methodsFor: 'as yet unclassified' stamp: 'Gwenael.Casaccio 2/6/2009 14:01'!doesNotUnderstand: aMessage"	aMessage arguments size = 0 ifTrue:[^nil].	aMessage arguments size = 1 ifTrue:[^self primitiveAt: aMessage selector put: aMessage arguments first].	Transcript show: aMessage selector"	^ MessageNotUnderstood new 		message: aMessage;		receiver: self;		signal! !!Lobby methodsFor: 'accessing' stamp: 'Gwenael.Casaccio 2/6/2009 13:35'!format	^ format! !!Lobby methodsFor: 'accessing' stamp: 'Gwenael.Casaccio 2/6/2009 13:35'!format: anObject	format := anObject! !!Lobby methodsFor: 'compiling' stamp: 'Gwenael.Casaccio 2/6/2009 13:35'!includesSelector: aSymbol	^ self methods includesKey: aSymbol! !!Lobby methodsFor: 'compiling' stamp: 'Gwenael.Casaccio 2/6/2009 13:53'!inheritsFrom: aClass 	"Answer whether the argument, aClass, is on the receiver's superclass 	chain."	| aSuperPrototype |	aSuperPrototype := delegate.	[aSuperPrototype == Lobby root delegate]		whileFalse: 			[aSuperPrototype == aClass ifTrue: [^true].			aSuperPrototype := aSuperPrototype delegate].	^false! !!Lobby methodsFor: 'primitive' stamp: 'Gwenael.Casaccio 2/6/2009 13:42'!initialize	delegate := Lobby.	methods := Lobby methodDictionary.	format := Lobby format.	instanceVariables := #('delegate' 'methods' 'format' 'instanceVariables' 'organization').	organization := Lobby organization! !!Lobby methodsFor: 'primitive' stamp: 'Gwenael.Casaccio 2/6/2009 14:36'!initializeVar	delegate := Lobby.	methods := Lobby methodDictionary.	format := LobbyVar format.	instanceVariables := #('delegate' 'methods' 'format' 'instanceVariables' 'organization').	organization := Lobby organization! !!Lobby methodsFor: 'compiling' stamp: 'Gwenael.Casaccio 2/6/2009 13:35'!instSize	"Answer the number of named instance variables	(as opposed to indexed variables) of the receiver."	self flag: #instSizeChange.  "Smalltalk browseAllCallsOn: #instSizeChange""	NOTE: This code supports the backward-compatible extension to 8 bits of instSize.	When we revise the image format, it should become...	^ ((format bitShift: -1) bitAnd: 16rFF) - 1	Note also that every other method in this category will require	2 bits more of right shift after the change."	^ ((format bitShift: -10) bitAnd: 16rC0) + ((format bitShift: -1) bitAnd: 16r3F) - 1! !!Lobby methodsFor: 'inspector' stamp: 'Gwenael.Casaccio 2/6/2009 14:19'!instSpec	^ (format bitShift: -7) bitAnd: 16rF! !!Lobby methodsFor: 'accessing' stamp: 'Gwenael.Casaccio 2/6/2009 13:35'!instanceVariables	^ instanceVariables! !!Lobby methodsFor: 'inspector' stamp: 'Gwenael.Casaccio 2/6/2009 14:19'!isVariable	"Answer whether the receiver has indexable variables."	^ self instSpec >= 2! !!Lobby methodsFor: 'compiling' stamp: 'Gwenael.Casaccio 2/6/2009 17:53'!literalScannedAs: scannedLiteral notifying: requestor	"Postprocesses a literal scanned by Scanner scanToken (esp. xLitQuote).	If scannedLiteral is not an association, answer it.	Else, if it is of the form:		nil->#NameOfMetaclass	answer nil->theMetaclass, if any has that name, else report an error.	Else, if it is of the form:		#NameOfGlobalVariable->anythiEng	answer the global, class, or pool association with that nameE, if any, else	add it to Undeclared a answer the new Association."	| key value |	(scannedLiteral isVariableBinding)		ifFalse: [^ scannedLiteral].	key := scannedLiteral key.	value := scannedLiteral value.	key isNil 		ifTrue: "###<metaclass soleInstance name>"			[(self bindingOf: value) ifNotNilDo:[:assoc|				 (assoc value isKindOf: Behavior)					ifTrue: [^ nil->assoc value class]].			 requestor notify: 'No such metaclass'.			 ^false].	(key isSymbol)		ifTrue: "##<global var name>"			[(self bindingOf: key) ifNotNilDo:[:assoc | ^assoc].			Undeclared at: key put: nil.			 ^Undeclared bindingOf: key].	requestor notify: '## must be followed by a non-local variable name'.	^false! !!Lobby methodsFor: 'compiling' stamp: 'Gwenael.Casaccio 2/6/2009 13:52'!lookupSelector: selector		| lookupClass |	lookupClass := self.	[lookupClass == Lobby root delegate]		whileFalse: 			[(lookupClass includesSelector: selector)				ifTrue: [^ lookupClass compiledMethodAt: selector].			lookupClass := lookupClass delegate].	^ nil! !!Lobby methodsFor: 'accessing' stamp: 'Gwenael.Casaccio 2/6/2009 13:35'!methods	^ methods! !!Lobby methodsFor: 'accessing' stamp: 'Gwenael.Casaccio 2/6/2009 13:35'!methods: anObject	methods := anObject! !!Lobby methodsFor: 'as yet unclassified' stamp: 'Gwenael.Casaccio 2/6/2009 17:51'!name	^ 'Lobby'! !!Lobby methodsFor: 'instance creation' stamp: 'ms 2/7/2009 13:32'!new: aString	| clone |	clone := self clone.	clone name: aString.	clone addToEnvrionment.	^ clone! !!Lobby methodsFor: 'primitive' stamp: 'Gwenael.Casaccio 2/6/2009 15:35'!primitiveAt: selector	| slot |	slot := Lobby slotFor: self.	self methods at: selector put: slot.	self methods at: (selector, ':') asSymbol  put: slot! !!Lobby methodsFor: 'primitive' stamp: 'Gwenael.Casaccio 2/6/2009 15:45'!primitiveAt: selector put: value	self primitiveAt: selector.	self perform: (selector, ':') asSymbol with: value! !!Lobby methodsFor: 'primitive' stamp: 'Gwenael.Casaccio 2/6/2009 13:35'!primitiveNew	<primitive: 70>! !!Lobby methodsFor: 'primitive' stamp: 'Gwenael.Casaccio 2/6/2009 13:35'!primitiveNew: size	<primitive: 71>! !!Lobby methodsFor: 'instance creation' stamp: 'ms 2/10/2009 12:43'!removeFromEnvrionment	| p |	p := self environment at: self name asSymbol ifAbsent:[nil].	p = self ifFalse:[self notify: 'Object not in env, procede to remove your parent'].	self environment removeKey: self name asSymbol ifAbsent: [self notify: 'There is something not right, Your proto do not have a named parent']! !!Lobby methodsFor: 'inspector' stamp: 'Gwenael.Casaccio 2/6/2009 14:17'!withAllSuperclassesDo: aBlock	ClassDescription withAllSuperclassesDo: aBlock! !Lobby variableSubclass: #LobbyVar	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'AlternativePrototype'!TestCase variableSubclass: #LobbyTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'AlternativePrototype'!!LobbyTest methodsFor: 'as yet unclassified' stamp: 'ms 2/10/2009 12:26'!testClasseBinding	| p |	Lobby reboot.		self assert: Lobby root name = 'Lobby'.	Lobby root new: 'Test'.	p := Lobby root clone.	p compile: 'refProto		^Test name'.	self assert: p refProto = 'Test'		! !!LobbyTest methodsFor: 'as yet unclassified' stamp: 'ms 2/7/2009 13:37'!testName	| p |	p := Lobby root clone.	p name: 'F'.	self assert: p name = 'F'.	self assert: Lobby root name = 'Lobby'! !!LobbyTest methodsFor: 'as yet unclassified' stamp: 'ms 2/7/2009 13:36'!testReboot	Lobby root name:  'F'.	Lobby reboot.		self assert: Lobby root name = 'Lobby'! !!LobbyTest methodsFor: 'as yet unclassified' stamp: 'ms 2/10/2009 12:47'!testRemoveFromEnv	| p |	Lobby reboot.	p := Lobby root new: 'IsRemoved'.	p removeFromEnvrionment.	self assert: (Lobby root environment at: 'IsRemoved' ifAbsent:[7]) = 7! !Lobby initialize!